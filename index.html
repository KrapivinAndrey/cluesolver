<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://gregstoll.com/cluesolver/"/>
        <title>Clue Solver</title>

        <!--#include virtual="/bootstraphead.html"-->
        <!-- The core React library -->
        <script src="https://npmcdn.com/react@15.3.0/dist/react-with-addons.min.js"></script>
        <!-- The ReactDOM Library -->
        <script src="https://npmcdn.com/react-dom@15.3.0/dist/react-dom.min.js"></script>
        <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
        <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.0.min.js"></script>
        <script src="react-tabs.min.js"></script>
        <style>
            body {
                /*color: black;
                font-family: Helvetica, Arial, sans-serif;*/
                font-size: 14px;
            }
            .warning { color: red; background-color: #ddd;}
            .working { text-align: center; position: fixed; top: 0px; left: 50%; z-index: 101}
            .workingInner { background-color: lightYellow; }

            input[type="radio"] {
               border-radius: 100% !important;
               margin-block-end: 0;
               margin-block-start: 3px;
               margin-inline-end: 3px;
               margin-inline-start: 5px;
            }
            .playerHeader { padding-left: 5px; padding-right: 5px; }

        </style>
    </head>
    <body>
  <!--#include virtual="/navbar.html"-->
        <div class="container">
        <h1>Clue Solver</h1>
        <p><a href="#about">About this project</a></p>
        <div id="reactTarget"></div>
        <p id="about"><b>About this project:</b> <a href="http://en.wikipedia.org/wiki/Cluedo">Clue</a> (or Cluedo outside of North America) is a game published
by Hasbro in which players make accusations to try to determine who killed Mr.
Boddy.  This application takes information about the game (including what cards
you have and which suggestions are disproved by whom) to figure out who has
which cards, and thus who the killer is.</p>
        <p>To get a quick start, load one of these sample clue games and play around with the Game Info and Simulations:</p>
        <ul>
            <li>63-QLU.3-ANQIHOLUMG.3-QLU-AMG-ANH-AOI.3QLU-AFECSNBTIHKOGRPMJD.3-QLU.3-QLU.3-QLU.</li>
            <li>54TNJS-AFECBIHKOLURQPMGD.4-ANSTOJ-FHP.4-ANSTOKJP.3-FNSHTJP-AO-AK.3-FNSHTJP.3-TNJS. (the simulation for this one has lots of colors :-) )</li>
        </ul>
        <p>The front-end was developed using <a href="https://facebook.github.io/react/">React</a>, the back-end is written in Python, and
        they communicate in the <a href="http://json.org">JSON</a> data format.  A previous version of this <a href="/cluesolver_gwt/">used the Google Web Toolkit</a>.</p>
        <p>I originally tried to write the back-end using first-order logic (see
<a href="https://gregstoll.wordpress.com/tag/cluesolver">discussions on my
blog</a>), and then propositional logic, but ended up rolling my own
deduction, which was sort of disappointing.</p>
        <p>The simulations are only reliable to within a few percent (it only
does 2000 of them) - basically it chooses each possible solution, tries to
assign cards to each player and sees if the solution is consistent or not (and if so, counts it).</p>
        <p>The images on the Game Info tab are taken from the <a href="http://www.famfamfam.com/lab/icons/silk/">Silk icon set at famfamfam.com</a> - thanks!</p>
        <p>Clue is a registered trademark of Hasbro, inc.  <a href="http://www.hasbro.com/games/parkerbrothers/clue/">Official Clue site</a></p>
  <p>Here are my source files:</p>
  <ul>
      <li>The UI code (using the React framework) is all in this file - just View Source to take a look!</li>
      <li><a href="clueengine.py.txt">clueengine.py</a> - the Python backend that does the deductions and simulations.</li>
      <li><a href="clue.py.txt">clue.py</a> - the CGI script that handles communications between the frontend and cluesolver.py.</li>
  </ul>

        <!--#include virtual="/endOfBody.html"-->
        
        <script type="text/babel">
          var SCRIPT_NAME = "clue.cgi";
          var MIN_PLAYERS = 3;
          var MAX_PLAYERS = 6;
          var MIN_CARDS = 3;
          var MAX_CARDS = 6;
          var DEFAULT_CARDS = 3;
          var TOTAL_CARDS_FOR_PLAYERS = 18;
          var _INTERNAL_NAMES = [["ProfessorPlum", "ColonelMustard", "MrGreen", "MissScarlet", "MsWhite", "MrsPeacock"],
                                ["Knife", "Candlestick", "Revolver", "LeadPipe", "Rope", "Wrench"],
                                ["Hall", "Conservatory", "DiningRoom", "Kitchen", "Study", "Library", "Ballroom", "Lounge", "BilliardRoom"]];
          var _EXTERNAL_NAMES = [["Professor Plum", "Colonel Mustard", "Mr. Green", "Miss Scarlet", "Ms. White", "Mrs. Peacock"],
                                ["Knife", "Candlestick", "Revolver", "Lead Pipe", "Rope", "Wrench"],
                                ["Hall", "Conservatory", "Dining Room", "Kitchen", "Study", "Library", "Ballroom", "Lounge", "Billiard Room"]];
          function compareInternalCardsByCategory(card1, card2) {
              return categoryFromInternalCard(card1) - categoryFromInternalCard(card2);
          }
          function categoryFromInternalCard(card) {
              for (var i = 0; i < _INTERNAL_NAMES.length; ++i) {
                  if (_INTERNAL_NAMES[i].indexOf(card) != -1) {
                      return i;
                  }
              }
              return 10;
          }
          var CARD_TYPE_NAMES = ["Suspects", "Weapons", "Rooms"];
          var CARD_NAMES = [];
          for (var i = 0; i < _INTERNAL_NAMES.length; ++i) {
              CARD_NAMES.push([]);
              for (var j = 0; j < _INTERNAL_NAMES[i].length; ++j) {
                  CARD_NAMES[i].push({'card_type': i, 'index': j, 'internal': _INTERNAL_NAMES[i][j], 'external': _EXTERNAL_NAMES[i][j]});
              }
          }
          var CARD_STATES = Object.freeze({Unknown: 0, OwnedByPlayer: 1, OwnedByCasefile: 2});

          var NumberOfPlayerOption = React.createClass({
              handleChange: function() {
                  this.props.setNumberOfPlayers(this.props.thisNumberOfPlayers);
              },
              render: function() {
                  var id = "numberOfPlayersInput" + this.props.thisNumberOfPlayers;
                  return <span><input type="radio" name="numberOfPlayer" id={id} value="{this.props.thisNumberOfPlayers}" checked={this.props.thisNumberOfPlayers == this.props.numberOfPlayers} onChange={this.handleChange} disabled={!this.props.allowChange}/><label htmlFor={id}> {this.props.thisNumberOfPlayers}</label></span>;
              }
          });
          var NumberOfPlayers = React.createClass({
              render: function() {
                  var options = [];
                  for (var i = MIN_PLAYERS; i <= MAX_PLAYERS; ++i) {
                      options.push(<NumberOfPlayerOption thisNumberOfPlayers={i} numberOfPlayers={this.props.playerInfo.length} key={i} setNumberOfPlayers={this.props.setNumberOfPlayers} allowChange={this.props.allowChange}/>);
                  }
                  return <div><span>Number of players:</span><form style={{display: 'inline'}}>{options}</form></div>;
              }
          });
          var PlayerNumberOfCards = React.createClass({
              handleChange: function(e) {
                  this.props.setNumberOfCards(e.target.value);
              },
              render: function() {
                  var options = [];
                  for (var i = MIN_CARDS; i <= MAX_CARDS; i++) {
                      options.push(<option value={i} key={i}>{i}</option>);
                  }
                  return <select onChange={this.handleChange} disabled={!this.props.allowChange} value={this.props.num}>{options}</select>;
              },
          });
          var PlayerInfo = React.createClass({
              setNumberOfCards: function(numberOfCards) {
                  this.props.setNumberOfCards(this.props.index, parseInt(numberOfCards));
              },
              setPlayerName: function(e) {
                  this.props.setPlayerName(this.props.index, e.target.value);
              },
              render: function() {
                  return <div>Name:<input type="text" value={this.props.info[0]} onChange={this.setPlayerName}/> Number of cards:<PlayerNumberOfCards num={this.props.info[1]} setNumberOfCards={this.setNumberOfCards} allowChange={this.props.allowChange}/></div>;
              },
          });
          var PlayerList = React.createClass({
              render: function() {
                  var infos = [];
                  for (var i = 0; i < this.props.playerInfo.length; ++i) {
                      infos.push(<PlayerInfo index={i} key={i} info={this.props.playerInfo[i]} setNumberOfCards={this.props.setNumberOfCards} setPlayerName={this.props.setPlayerName} allowChange={this.props.allowChange}/>);
                  }
                  return <div>{infos}</div>;
              },
          });
          var NumberOfCardsValidator = React.createClass({
              render: function() {
                  var totalNumberOfCards = this.props.playerInfo.reduce(function(previousValue, currentValue) {
                      return previousValue + currentValue[1];
                  }, 0);
                  var badNumberOfCardsElem = null;
                  if (totalNumberOfCards != TOTAL_CARDS_FOR_PLAYERS) {
                      badNumberOfCardsElem = <span className="warning">Total number of cards must total {TOTAL_CARDS_FOR_PLAYERS}! (not {totalNumberOfCards})</span>;
                  }
                  return <div>{badNumberOfCardsElem}</div>;
              }
          });
          var GameSetup = React.createClass({
              getInitialState: function() {
                  return {loadGameString: ""};
              },
              handleRestartGame: function() {
                  this.props.newSession();
              },
              handleLoadGameStringChange: function(e) {
                  this.setState({loadGameString: e.target.value});
              },
              handleSetLoadGameString: function() {
                  this.props.setGameString(this.state.loadGameString);
              },
              render: function() {
                  return <div>
                    <NumberOfPlayers playerInfo={this.props.playerInfo} setNumberOfPlayers={this.props.setNumberOfPlayers} allowChange={!this.props.haveEnteredData}/>
                    <PlayerList playerInfo={this.props.playerInfo} setNumberOfCards={this.props.setNumberOfCards} setPlayerName={this.props.setPlayerName} allowChange={!this.props.haveEnteredData}/>
                    <NumberOfCardsValidator playerInfo={this.props.playerInfo} />
                    <button type="button" onClick={this.handleRestartGame} disabled={!this.props.haveEnteredData}>Restart game</button>
                    <div>Current game state (for loading later): {this.props.session}</div>
                    <div>Load game state: <input type="text" onChange={this.handleLoadGameStringChange} value={this.state.loadGameString}/></div>
                    <button type="button" onClick={this.handleSetLoadGameString}>Load game</button>
                  </div>;
              }
          });
          var SpecificCardInfo = React.createClass({
              getImgSrc: function() {
                  var name;
                  switch (this.props.info.state) {
                      case CARD_STATES.OwnedByPlayer:
                        name = 'cancel.png';
                        break;
                      case CARD_STATES.OwnedByCasefile:
                        name = 'accept.png';
                        break;
                      case CARD_STATES.Unknown:
                      default:
                        name = 'help.png';
                        break;
                  }
                  return 'images/' + name;
              },
              getOwnedByString: function() {
                  if (this.props.info.owners && !(this.props.info.owners.length  > 0)) {
                      return "???";
                  }
                  var s = "";
                  for (var i = 0; i < this.props.info.owners.length; ++i) {
                      var curIndex = this.props.info.owners[i];
                      if (curIndex == this.props.playerInfo.length) {
                          s += "(solution)";
                      }
                      else {
                          s += this.props.playerInfo[curIndex][0];
                      }
                      if (i < this.props.info.owners.length - 1) {
                          s += " or ";
                      }
                  }
                  return s;
              },
              getAltText: function() {
                  switch (this.props.info.state) {
                      case CARD_STATES.OwnedByPlayer:
                        return "Owned by " + this.getOwnedByString();
                        break;
                      case CARD_STATES.OwnedByCasefile:
                        return "Solution!";
                        break;
                      case CARD_STATES.Unknown:
                      default:
                        if (this.props.info.owners && this.props.info.owners.length > 0) {
                            return "Owned by " + this.getOwnedByString();
                        } else {
                            return "Unknown";
                        }
                        break;
                  }
              },
              render: function() {
                  return <tr><td style={{paddingLeft: 20, textAlign: 'left'}}>{CARD_NAMES[this.props.info.card_type][this.props.info.index].external}</td><td><img src={this.getImgSrc()} alt={this.getAltText()} title={this.getAltText()}/></td></tr>;
              }
          });
          var RefutingCardSelector = React.createClass({
              handleChange: function(e) {
                  this.props.setCardIndex(e.target.value.split(" ").map(function(x) { return parseInt(x, 10); }));
              },
              render: function() {
                  var options = [];
                  var invalidSelectedCard = true;
                  options.push(<option value="-1 -1" key="-1">None/Unknown</option>);
                  var selectedCardIndexString = this.props.cardIndex.join(' ');
                  if (selectedCardIndexString == "-1 -1") {
                      invalidSelectedCard = false;
                  }
                  for (var i = 0; i < this.props.cardIndices.length; ++i) {
                      var cardInfo = CARD_NAMES[i][this.props.cardIndices[i]];
                      var cardIndexString = cardInfo['card_type'] + ' ' + cardInfo.index;
                      if (selectedCardIndexString == cardIndexString) {
                          invalidSelectedCard = false;
                      }
                      options.push(<option value={cardIndexString} key={cardInfo['card_type']}>{cardInfo.external}</option>);
                  }
                  if (invalidSelectedCard) {
                      // this happens if there's a selected refuting card, and then
                      // the choices change so this isn't an option anymore
                      this.props.setCardIndex([-1, -1]);
                  }
                  return <span>Refuting card: <select value={selectedCardIndexString} onChange={this.handleChange}>{options}</select></span>;
              }
          });

          var CardSelector = React.createClass({
              handleChange: function(e) {
                  this.props.setCardIndex(e.target.value.split(" ").map(function(x) { return parseInt(x, 10); }));
              },
              render: function() {
                  var options = [];
                  var allCardTypes = this.props.cardType == -1;
                  var iMin = allCardTypes ? 0 : this.props.cardType;
                  var iMax = allCardTypes ? CARD_TYPE_NAMES.length : (this.props.cardType + 1);
                  var label = allCardTypes ? "Card" : CARD_TYPE_NAMES[this.props.cardType];
                  for (var i = iMin; i < iMax; ++i) {
                      for (var j = 0; j < CARD_NAMES[i].length; ++j) {
                          options.push(<option value={i + ' ' + j} key={i + ' ' + j}>{CARD_NAMES[i][j].external}</option>);
                      }
                  }
                  return <span>{label}: <select value={this.props.cardIndex.join(' ')} onChange={this.handleChange}>{options}</select></span>;
              }
          });
          var PlayerSelector = React.createClass({
              handleChange: function(e) {
                  this.props.setPlayerIndex(parseInt(e.target.value));
              },
              render: function() {
                  var options = [];
                  if (this.props.includeNone) {
                      options.push(<option value={-1} key={-1}>None</option>);
                  }
                  for (var i = 0; i < this.props.playerInfo.length; ++i) {
                      options.push(<option value={i} key={i}>{this.props.playerInfo[i][0]}</option>);
                  }
                  if (this.props.includeSolution) {
                      options.push(<option value={this.props.playerInfo.length} key={this.props.playerInfo.length}>Solution (case file)</option>);
                  }
                  return <span>{this.props.label}: <select value={this.props.playerIndex} onChange={this.handleChange}>{options}</select></span>
              }
          });
          var SuggestACard = React.createClass({
              getInitialState: function() {
                  return {suggestingPlayerIndex: 0, refutingPlayerIndex: -1, cardIndices: [0, 0, 0], refutingCardIndex: [-1, -1]};
              },
              setSuggestingPlayerIndex: function(playerIndex) {
                  this.setState({suggestingPlayerIndex: playerIndex});
              },
              setRefutingPlayerIndex: function(playerIndex) {
                  this.setState({refutingPlayerIndex: playerIndex});
              },
              setRefutingCardIndex: function(cardIndex) {
                  this.setState({refutingCardIndex: cardIndex});
              },
              setCardIndex: function(cardIndex) {
                  // TODO - need to copy?
                  var newCardIndices = this.state.cardIndices;
                  newCardIndices[cardIndex[0]] = cardIndex[1];
                  this.setState({cardIndices: newCardIndices});
              },
              sendSuggestion: function() {
                  var data = "sess=" + this.props.session + "&action=suggestion&suggestingPlayer=" + this.state.suggestingPlayerIndex;
                  for (var i = 0; i < CARD_TYPE_NAMES.length; ++i) {
                      data += "&card" + (i+1) + "=" + CARD_NAMES[i][this.state.cardIndices[i]].internal;
                  }
                  data += "&refutingPlayer=" + this.state.refutingPlayerIndex + "&refutingCard=";
                  if (this.state.refutingCardIndex[0] == -1 && this.state.refutingCardIndex[1] == -1) {
                      data += "None";
                  }
                  else {
                      data += CARD_NAMES[this.state.refutingCardIndex[0]][this.state.refutingCardIndex[1]].internal;
                  }
                  var description = ['suggestion', this.state.suggestingPlayerIndex, this.state.cardIndices[0], this.state.cardIndices[1], this.state.cardIndices[2], this.state.refutingPlayerIndex, this.state.refutingCardIndex];
                  var that = this;
                  this.props.sendClueRequest(data, function(json) {
                      that.props.addToHistory(description);
                      that.props.updateInfoFromJson(json, true);
                  }, function(errorText) {
                      alert('Error: ' + errorText);
                  });
              },
              render: function() {
                  // TODO - hide suggesting player in refuting player box?
                  return <div>
                      <div><PlayerSelector label="Made by" includeSolution={false} playerInfo={this.props.playerInfo} playerIndex={this.state.suggestingPlayerIndex} setPlayerIndex={this.setSuggestingPlayerIndex}/></div>
                      <div><CardSelector cardType={0} cardIndex={[0, this.state.cardIndices[0]]} setCardIndex={this.setCardIndex}/></div>
                      <div><CardSelector cardType={1} cardIndex={[1, this.state.cardIndices[1]]} setCardIndex={this.setCardIndex}/></div>
                      <div><CardSelector cardType={2} cardIndex={[2, this.state.cardIndices[2]]} setCardIndex={this.setCardIndex}/></div>
                      <div><PlayerSelector label="Refuted by" includeSolution={false} includeNone={true} playerInfo={this.props.playerInfo} playerIndex={this.state.refutingPlayerIndex} setPlayerIndex={this.setRefutingPlayerIndex}/></div>
                      <div><RefutingCardSelector cardIndex={this.state.refutingCardIndex} cardIndices={this.state.cardIndices} setCardIndex={this.setRefutingCardIndex} /></div>
                      <button type="button" onClick={this.sendSuggestion}>Add info</button>
                  </div>;
              }

          });
          var WhoOwnsACard = React.createClass({
              getInitialState: function() {
                  return {cardIndex: [0, 0], playerIndex: 0};
              },
              setCardIndex: function(newCardIndex) {
                  this.setState({cardIndex: newCardIndex});
              },
              setPlayerIndex: function(newPlayerIndex) {
                  this.setState({playerIndex: newPlayerIndex});
              },
              sendWhoOwnsACard: function()
              {
                  var data = "sess=" + this.props.session + "&action=whoOwns&owner=" + this.state.playerIndex + "&card=" + CARD_NAMES[this.state.cardIndex[0]][this.state.cardIndex[1]].internal;
                  var description = ['whoOwns', this.state.playerIndex, this.state.cardIndex];
                  var that = this;
                  this.props.sendClueRequest(data, function(json) {
                      that.props.addToHistory(description);
                      that.props.updateInfoFromJson(json, true);
                  }, function(errorText) {
                      alert('Error: ' + errorText);
                  });
              },
              render: function() {
                  return <div>
                      <div><CardSelector cardType={-1} cardIndex={this.state.cardIndex} setCardIndex={this.setCardIndex}/></div>
                      <div><PlayerSelector label="Owned by" includeSolution={true} includeNone={false} playerInfo={this.props.playerInfo} playerIndex={this.state.playerIndex} setPlayerIndex={this.setPlayerIndex}/></div>
                      <button type="button" onClick={this.sendWhoOwnsACard}>Add info</button>
                  </div>;
              }
          });
          var ClauseInfo = React.createClass({
              render: function() {
                  var rows = [];
                  for (var playerIndex in this.props.clauseInfo) {
                      // make a copy since we're modifying it
                      var info = this.props.clauseInfo[playerIndex].slice();
                      for (var i = 0; i < info.length; ++i) {
                          var s = this.props.playerInfo[playerIndex][0] + " has ";
                          var names = info[i].sort(compareInternalCardsByCategory).map(function(x) { return CARD_NAMES[x[0]][x[1]].external; });
                          s += names.join(' or ');
                          rows.push(<tr key={playerIndex + ' ' + i}><td>{s}</td></tr>);
                      }
                  }
                  return <table><tbody>{rows}</tbody></table>;
              }
          });
          var GameInfo = React.createClass({
              render: function() {
                  var infoRows = [];
                  for (var i = 0; i < CARD_TYPE_NAMES.length; ++i) {
                      infoRows.push(<tr key={i}><th style={{textAlign: 'left'}}>{CARD_TYPE_NAMES[i]}</th><th></th></tr>);
                      for (var j = 0; j < this.props.cardInfo[i].length; ++j) {
                          infoRows.push(<SpecificCardInfo key={i + ' ' + j} info={this.props.cardInfo[i][j]} playerInfo={this.props.playerInfo}/>);
                      }
                  }
                  return <div><div style={{cssFloat: 'left'}}><div className="warning">{!this.props.isConsistent && "Game is no longer consistent!"}</div><table><tbody>{infoRows}</tbody></table></div><div style={{cssFloat: 'left'}}>Enter new info:
                    <ReactTabs.Tabs>
                        <ReactTabs.TabList>
                            <ReactTabs.Tab>Who owns a card</ReactTabs.Tab>
                            <ReactTabs.Tab>Suggestion made</ReactTabs.Tab>
                        </ReactTabs.TabList>
                        <ReactTabs.TabPanel>
                            <WhoOwnsACard playerInfo={this.props.playerInfo} session={this.props.session} updateInfoFromJson={this.props.updateInfoFromJson} addToHistory={this.props.addToHistory} sendClueRequest={this.props.sendClueRequest} />
                        </ReactTabs.TabPanel>
                        <ReactTabs.TabPanel>
                            <SuggestACard playerInfo={this.props.playerInfo} session={this.props.session} updateInfoFromJson={this.props.updateInfoFromJson} addToHistory={this.props.addToHistory} sendClueRequest={this.props.sendClueRequest} />
                        </ReactTabs.TabPanel>
                    </ReactTabs.Tabs>
                  </div>
                  <div style={{clear: 'both'}}/><ClauseInfo clauseInfo={this.props.clauseInfo} playerInfo={this.props.playerInfo} /></div>;
              }
          });
          var History = React.createClass({
              doUndo: function() {
                  this.props.doUndo();
              },
              render: function() {
                  var entries = [];
                  for (var i = 0; i < this.props.history.length; ++i)
                  {
                      var event = this.props.history[i][0];
                      var eventType = event[0];
                      var description = '';
                      if (eventType === "suggestion") {
                          description = this.props.playerInfo[event[1]][0] + " suggested " + CARD_NAMES[0][event[2]].external + ", " + CARD_NAMES[1][event[3]].external + ", " + CARD_NAMES[2][event[4]].external + " ";
                          if (event[5] == -1) {
                              description += " - no one refuted";
                          }
                          else {
                              description += " - refuted by " + this.props.playerInfo[event[5]][0] + " with card ";
                              if (event[6][0] == -1 && event[6][1] == -1) {
                                  description += "Unknown";
                              }
                              else {
                                  description += CARD_NAMES[event[6][0]][event[6][1]].external;
                              }
                          }
                      } else if (eventType === "whoOwns") {
                          var player = "Solution (case file)";
                          if (event[1] < this.props.playerInfo.length) {
                              player = this.props.playerInfo[event[1]][0];
                          }
                          description = CARD_NAMES[event[2][0]][event[2][1]].external + " owned by " + player;
                      }
                      entries.push(<li key={i}>{description}</li>);
                  }

                  return <div>
                    <ul>{entries}</ul>
                    <div><button type="button" disabled={entries.length == 0} onClick={this.doUndo}>Undo latest information</button></div>
                  </div>;
              }
          });
          var Simulation = React.createClass({
              doSimulate: function() {
                  this.props.setDoingSimulation(true);
                  var that = this;
                  this.props.sendClueRequest('sess=' + this.props.session + '&action=simulate', function(json) {
                      var simData = {};
                      var totalNumberOfSims = 0;
                      for (var key in json.simData) {
                          var data = json.simData[key];
                          totalNumberOfSims = data.reduce(function(previousValue, currentValue) { return previousValue + currentValue; }, 0);
                          var cardIndex = that.props.cardIndexFromInternalName(key);
                          var cardKey = cardIndex[0] + ' ' + cardIndex[1];
                          if (totalNumberOfSims > 0) {
                              simData[cardKey] = data.map(function(x) { return x / totalNumberOfSims;});
                          } else {
                              simData[cardKey] = data.map(function(x) { return 0.0; });
                          }
                      }
                      that.props.setDoingSimulation(false);
                      that.props.setNumberOfSimulations(totalNumberOfSims);
                      that.props.setSimulationData(simData);
                  }, function(errorText) {
                      alert('Error: ' + errorText);
                      that.props.setDoingSimulation(false);
                  },
                  true);
              },
              interpolateBetween: function(percent, colorArray) {
                  var quartiles = colorArray.length - 1;
                  var quartileSpan = 100 / quartiles;
                  var quartile = Math.floor((percent / 100) * quartiles);
                  if (quartile >= quartiles) {
                      quartile = quartiles - 1;
                  }
                  var r = colorArray[quartile][0] + (colorArray[quartile+1][0] - colorArray[quartile][0]) * ((percent - quartile * quartileSpan) / quartileSpan);
                  var g = colorArray[quartile][1] + (colorArray[quartile+1][1] - colorArray[quartile][1]) * ((percent - quartile * quartileSpan) / quartileSpan);
                  var b = colorArray[quartile][2] + (colorArray[quartile+1][2] - colorArray[quartile][2]) * ((percent - quartile * quartileSpan) / quartileSpan);
                  return {backgroundColor: 'rgb(' + Math.round(r) + ', ' + Math.round(g) + ', ' + Math.round(b) + ')', textAlign: 'right'};
              },
              getColorProp: function(percent) {
                  // Interpolation between
                  // (3, 146, 207) blue
                  // (123, 192, 67) green
                  //// (253, 244, 152) yellow
                  // (243, 119, 54) orange
                  // (238, 64, 53) red
                  // http://www.color-hex.com/color-palette/807
                  return this.interpolateBetween(percent,
                      [[3, 146, 207],
                       [123, 192, 67],
                       //[253, 244, 152],
                       [243, 119, 54],
                       [238, 64, 53]
                       ]);
              },
              render: function() {
                  var infoRows = [];
                  var playerHeaderEntries = [];
                  for (var i = 0; i < this.props.playerInfo.length; ++i) {
                      playerHeaderEntries.push(<th className="playerHeader" key={"player" + i}>{this.props.playerInfo[i][0]}</th>);
                  }
                  playerHeaderEntries.push(<th className="playerHeader" key="solution">Solution</th>);
                  for (var i = 0; i < CARD_TYPE_NAMES.length; ++i) {
                      infoRows.push(<tr key={i}><th style={{textAlign: 'left'}}>{CARD_TYPE_NAMES[i]}</th>{i == 0 ? playerHeaderEntries : undefined}</tr>);
                      for (var j = 0; j < CARD_NAMES[i].length; ++j) {
                          var cells = [<td key="cardName">{CARD_NAMES[i][j].external}</td>];
                          var dataArray = this.props.simData[i + ' ' + j];
                          for (var k = 0; k < this.props.playerInfo.length; ++k) {
                              var v = '';
                              var c = {};
                              if (dataArray != undefined && dataArray[k] !== undefined) {
                                  v = (Math.round(dataArray[k] * 1000) / 10);
                                  c = this.getColorProp(v);
                                  v = Number(v).toFixed(1) + '%';
                              }
                              cells.push(<td style={c} key={"player" + k}>{v}</td>);
                          }
                          var sv = '';
                          var sc = {};
                          if (dataArray != undefined && dataArray[this.props.playerInfo.length] !== undefined) {
                              sv = (Math.round(dataArray[this.props.playerInfo.length] * 1000) / 10);
                              sc = this.getColorProp(sv);
                              sv = Number(sv).toFixed(1) + '%';
                          }
                          cells.push(<td style={sc} key="solution">{sv}</td>);
                          infoRows.push(<tr key={i + ' ' + j}>{cells}</tr>);
                      }
                  }
                  var working = undefined;
                  if (this.props.doingSimulation) {
                      working = <img src="images/loading.gif"/>;
                  }
                  var simulationSpan = undefined;
                  if (this.props.numberOfSimulations > -1) {
                      if (this.props.numberOfSimulations > 0) {
                          simulationSpan = <span style={{marginLeft: 20, fontStyle: "italic"}}>Simulations done: {this.props.numberOfSimulations}</span>;
                      } else {
                          simulationSpan = <span className="warning" style={{marginLeft: 20, fontStyle: "italic"}}>No simulations done!</span>;
                      }
                  }
                  return <div>
                    <div className="warning">{!this.props.isConsistent && "Game is no longer consistent!"}</div>
                    <div><button type="button" onClick={this.doSimulate} disabled={this.props.doingSimulation}>Simulate</button>{working}{simulationSpan}</div>
                    <div style={{display: 'flex'}}>
                        <table><tbody>{infoRows}</tbody></table>
                        <div style={{display: 'flex', verticalAlign: 'top', flexDirection: 'row', height: 300}}><img src="images/rainbow.png" style={{height: 300, width: 50}}/><div style={{display: 'flex', flexDirection: 'column', height: 300}}><div style={{alignSelf: 'flex-start'}}>0%</div><div style={{flex: 1}}/><div style={{alignSelf: 'flex-end'}}>100%</div></div></div>
                    </div>
                </div>;
              }
          });
          var App = React.createClass({
              getInitialState: function() {
                  // TODO - parse query hash from window.location.hash?
                  var playerInfo = [];
                  for (var i = 1; i <= MAX_PLAYERS; ++i)
                  {
                      playerInfo.push(['Player ' + i, DEFAULT_CARDS]);
                  }
                  var cardInfo = [];
                  for (var i = 0; i < CARD_NAMES.length; ++i) {
                      cardInfo.push([]);
                      for (var j = 0; j < CARD_NAMES[i].length; ++j) {
                          cardInfo[i].push({'card_type': i, 'index': j, 'state': CARD_STATES.Unknown, 'owners': []});
                      }
                  }

                  return {'playerInfo': playerInfo, 'cardInfo': cardInfo, 'isConsistent': true, 'haveEnteredData': false, 'clauseInfo': {}, 'history': [], 'working': false, 'simData': {}, 'doingSimulation': false, 'numberOfSimulations': -1};
              },
              internalSetNumberOfPlayers: function(previousPlayerInfo, numberOfPlayers) {
                  var playerInfo = previousPlayerInfo.slice(0, previousPlayerInfo.length);
                  if (playerInfo.length == numberOfPlayers) {
                      return playerInfo;
                  }
                  if (playerInfo.length > numberOfPlayers) {
                      playerInfo = playerInfo.slice(0, numberOfPlayers);
                  }
                  else {
                      while (playerInfo.length < numberOfPlayers) {
                          // use DEFAULT_CARDS here, will fix afterwards
                          playerInfo.push(['Player ' + (playerInfo.length + 1), DEFAULT_CARDS]);
                      }
                  }
                  var baseCards = Math.floor(TOTAL_CARDS_FOR_PLAYERS / numberOfPlayers);
                  var numWhoGetExtra = (TOTAL_CARDS_FOR_PLAYERS - baseCards * numberOfPlayers) % numberOfPlayers;
                  for (var i = 0; i < playerInfo.length; ++i) {
                      var numCards = baseCards;
                      if (i < numWhoGetExtra) {
                          numCards++;
                      }
                      playerInfo[i][1] = numCards;
                  }
                  return playerInfo;
              },
              setNumberOfPlayers: function(numberOfPlayers) {
                  var that = this;
                  this.setState(function(previousState, currentProps) {
                      return {'playerInfo': this.internalSetNumberOfPlayers(previousState.playerInfo, numberOfPlayers)};
                  }, function(state, props) {
                      that.newSession();
                  });
              },
              setPlayerName: function(playerIndex, playerName) {
                  this.setState(function(previousState, currentProps) {
                      var playerInfo = previousState.playerInfo.slice(0, previousState.playerInfo.length);
                      playerInfo[playerIndex][0] = playerName;
                      return {'playerInfo': playerInfo};
                  });
              },
              setNumberOfCards: function(playerIndex, numberOfCards) {
                  var that = this;
                  this.setState(function(previousState, currentProps) {
                      var playerInfo = previousState.playerInfo.slice(0, previousState.playerInfo.length);
                      playerInfo[playerIndex][1] = numberOfCards;
                      return {'playerInfo': playerInfo};
                  }, function(state, props) {
                      that.newSession();
                  });
              },
              newSession: function() {
                  var data = "action=new&players=" + this.state.playerInfo.length;
                  for (var i = 0; i < this.state.playerInfo.length; ++i) {
                      data += "&numCards" + i + "=" + this.state.playerInfo[i][1];
                  }
                  var myApp = this;
                  this.sendClueRequest(data, function(json) {
                      myApp.setState({'session': json.session, 'history': []});
                      myApp.updateCardInfo(json.session, false);
                  }, function(errorText) {
                      alert('Error: ' + errorText);
                  });
              },
              cardIndexFromInternalName: function(name) {
                  // TODO - optimize this
                  for (var i = 0; i < CARD_NAMES.length; ++i) {
                      for (var j = 0; j < CARD_NAMES[i].length; ++j) {
                          if (CARD_NAMES[i][j].internal === name) {
                              return [i, j];
                          }
                      }
                  }
                  return [-1, -1];
              },
              setGameString: function(s) {
                  this.setState({session: s});
                  this.updateCardInfo(s, true);
              },
              updateCardInfo: function(session, haveEnteredData, callback) {
                  var data = "sess=" + session + "&action=fullInfo";
                  var myApp = this;
                  this.sendClueRequest(data, function(json) {
                      if (callback) {
                          callback();
                      }
                      myApp.updateInfoFromJson(json, haveEnteredData);
                  }, function(errorText) {
                      alert('Error: ' + errorText);
                  });
              },
              updateInfoFromJson: function(json, haveEnteredData) {
                  var playerInfo = this.state.playerInfo;
                  if (json.numPlayers) {
                      playerInfo = this.internalSetNumberOfPlayers(this.state.playerInfo, json.numPlayers);
                      for (var i = 0; i < json.numPlayers; ++i) {
                          playerInfo[i][1] = json.numCards[i];
                      }
                  }
                  var totalCards = playerInfo.reduce(function(previousValue, currentValue) {
                      return previousValue + currentValue[1];
                  }, 0);

                  var jsonClauseInfo = json.clauseInfo;
                  var clauseInfo = {};
                  if (jsonClauseInfo) {
                      for (var playerIndex in jsonClauseInfo) {
                          clauseInfo[playerIndex] = [];
                          for (var i = 0; i < jsonClauseInfo[playerIndex].length; ++i) {
                              var clause = [];
                              for (var j = 0; j < jsonClauseInfo[playerIndex][i].length; ++j) {
                                  clause.push(this.cardIndexFromInternalName(jsonClauseInfo[playerIndex][i][j]));
                              }
                              clauseInfo[playerIndex].push(clause);
                          }
                      }
                  }
                  var newInfo = json.newInfo;
                  //var newCardInfo = $.extend(true, {}, this.state.cardInfo);
                  var newCardInfo = this.state.cardInfo;
                  for (var i = 0; i < newInfo.length; ++i) {
                      var cardIndex = this.cardIndexFromInternalName(newInfo[i].card);
                      newCardInfo[cardIndex[0]][cardIndex[1]].state = newInfo[i].status;
                      newCardInfo[cardIndex[0]][cardIndex[1]].owners = newInfo[i].owner;
                  }
                  this.setState({'cardInfo': newCardInfo, 'playerInfo': playerInfo, 'session': json.session, 'clauseInfo': clauseInfo, 'isConsistent': json.isConsistent && totalCards == TOTAL_CARDS_FOR_PLAYERS, 'haveEnteredData': haveEnteredData});
              },
              addToHistory(entry) {
                  var session = this.state.session;
                  this.setState(function(previousState, currentProps) {
                      var history = previousState.history;
                      history.push([entry, session]);
                      return {'history': history};
                  });
              },
              doUndo: function() {
                  if (this.state.history.length > 0) {
                      var that = this;
                      this.updateCardInfo(this.state.history[this.state.history.length - 1][1], this.state.history.length > 1, function() {
                          that.setState({'history': that.state.history.slice(0, that.state.history.length - 1)});
                      });
                  }
              },
              setSimulationData: function(data) {
                  this.setState({simData: data});
              },
              setNumberOfSimulations: function(n) {
                  this.setState({numberOfSimulations: n});
              },
              setDoingSimulation: function(isDoingSimulation) {
                  this.setState({doingSimulation: isDoingSimulation});
              },
              sendClueRequest: function(data, successCallback, failureCallback, skipWorking) {
                  if (!skipWorking) {
                      this.setState({working: true});
                  }
                  var that = this;
                  $.ajax({url: SCRIPT_NAME, data: data, dataType: "json", complete: function(xhr, textStatus) {
                      if (!skipWorking) {
                          that.setState({working: false});
                      }
                      if (textStatus != "success" && textStatus != "notmodified") {
                          failureCallback('from jQuery: ' + textStatus);
                          return;
                      }
                      if (xhr.responseJSON.errorStatus != 0) {
                          failureCallback(xhr.responseJSON.errorText);
                          return;
                      }
                      successCallback(xhr.responseJSON);
                  }});
              },
              componentWillMount: function() {
                  this.newSession();
              },
              render: function() {
                  var working = undefined;
                  if (this.state.working) {
                      working = <p className="working"><span className="workingInner">Working...<img src="images/loading.gif"/></span></p>
                  }

                  return <div>
                  {working}
                  <ReactTabs.Tabs>
                  <ReactTabs.TabList>
                    <ReactTabs.Tab>Game setup</ReactTabs.Tab>
                    <ReactTabs.Tab>Game info</ReactTabs.Tab>
                    <ReactTabs.Tab>Undo and history</ReactTabs.Tab>
                    <ReactTabs.Tab>Simulation</ReactTabs.Tab>
                </ReactTabs.TabList>
                <ReactTabs.TabPanel>
                    <GameSetup playerInfo={this.state.playerInfo} setNumberOfPlayers={this.setNumberOfPlayers} setNumberOfCards={this.setNumberOfCards} setPlayerName={this.setPlayerName} session={this.state.session} haveEnteredData={this.state.haveEnteredData} setGameString={this.setGameString} newSession={this.newSession}/>
                </ReactTabs.TabPanel>
                <ReactTabs.TabPanel>
                    <GameInfo playerInfo={this.state.playerInfo} cardInfo={this.state.cardInfo} session={this.state.session} isConsistent={this.state.isConsistent} clauseInfo={this.state.clauseInfo} updateInfoFromJson={this.updateInfoFromJson} addToHistory={this.addToHistory} sendClueRequest={this.sendClueRequest} />
                </ReactTabs.TabPanel>
                <ReactTabs.TabPanel>
                    <History playerInfo={this.state.playerInfo} history={this.state.history} doUndo={this.doUndo} />
                </ReactTabs.TabPanel>
                <ReactTabs.TabPanel>
                    <Simulation playerInfo={this.state.playerInfo} session={this.state.session} isConsistent={this.state.isConsistent} sendClueRequest={this.sendClueRequest} cardIndexFromInternalName={this.cardIndexFromInternalName} simData={this.state.simData} numberOfSimulations={this.state.numberOfSimulations} doingSimulation={this.state.doingSimulation} setSimulationData={this.setSimulationData} setNumberOfSimulations={this.setNumberOfSimulations} setDoingSimulation={this.setDoingSimulation}/>
                </ReactTabs.TabPanel>
                </ReactTabs.Tabs>
              </div>;
              }
          });
          ReactDOM.render(<App/>, document.getElementById('reactTarget'));
        </script>
    </div>
    </body>
</html>
